#!/usr/bin/env python3
"""
Terminal Screensaver
A collection of mathematically-inspired visual effects for the terminal
I just hope this works well and i dont have to maintain it in future i am terrbible at python :)
"""
import curses
import random
import time
import math
import argparse
from typing import Callable, Dict
from dataclasses import dataclass


@dataclass
class ScreenState:
    """Holds current screen dimensions and provides utility methods"""

    height: int
    width: int

    @property
    def center(self) -> tuple[int, int]:
        return self.height // 2, self.width // 2

    def in_bounds(self, y: int, x: int) -> bool:
        return 0 <= y < self.height and 0 <= x < self.width


class BaseEffect:
    """Base class for screensaver effects"""
    # stdscr is from curses lib,
    def __init__(self, stdscr):
        self.stdscr = stdscr
        self.setup_screen()
        self.setup_colors()
    # curs_set does the apperance of cursor
    # nodelay specifies delay mode is a bool
    #  timeout guess what it does geniues?
    def setup_screen(self):
        curses.curs_set(0)
        self.stdscr.nodelay(1)
        self.stdscr.timeout(30)
    # fk it just read https://pubs.opengroup.org/onlinepubs/007908799/xcurses/curses.h.html
    def setup_colors(self):
        curses.start_color()
        for i in range(1, 8):
            curses.init_pair(i, i, curses.COLOR_BLACK)

    def get_screen_state(self) -> ScreenState:
        height, width = self.stdscr.getmaxyx()
        return ScreenState(height, width)

    def safe_addstr(self, y: int, x: int, char: str, attr=0):
        """Safely add string to screen with bounds checking"""
        try:
            self.stdscr.addstr(y, x, char, attr)
        except curses.error:
            pass

    def should_exit(self) -> bool:
        return self.stdscr.getch() != -1

    def run(self):
        raise NotImplementedError


class PlasmaWave(BaseEffect):
    """Beautiful plasma wave effect using sine and cosine"""

    CHARS = " fsa·:░▒▓█"

    def run(self):
        time_offset = 0

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()

            for y in range(screen.height):
                for x in range(screen.width):
                    val1 = math.sin(x / 12.0 + time_offset)
                    val2 = math.sin(y / 18.0 + time_offset * 1.3)
                    val3 = math.sin((x + y) / 10.0 + time_offset * 0.7)
                    val4 = math.sin(math.sqrt(x * x + y * y) / 8.0 + time_offset)

                    value = (val1 + val2 + val3 + val4) / 5.0
                    char_idx = int((value + 1) * (len(self.CHARS) - 1) / 2)
                    color_idx = min(int((value + 1) * 3.5) + 1, 7)
                    self.safe_addstr(y, x, self.CHARS[char_idx], curses.color_pair(color_idx))
            self.stdscr.refresh()
            time_offset += 0.1


class MatrixRain(BaseEffect):
    """Matrix-style digital rain with multiple effects"""
    CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789@#$%^&*()_+-=[]{}|;:,.<>?/"
    JAPANESE_CHARS = "ｱｲｳｴｵｶｷｸｹｺｻｼｽｾｿﾀﾁﾂﾃﾄﾅﾆﾇﾈﾉﾊﾋﾌﾍﾎﾏﾐﾑﾒﾓﾔﾕﾖﾗﾘﾙﾚﾛﾜｦﾝ0123456789"
    BINARY_CHARS = "01"

    def __init__(self, stdscr, variant="classic"):
        super().__init__(stdscr)
        self.variant = variant

    def setup_colors(self):
        super().setup_colors()
        curses.init_pair(1, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_CYAN, curses.COLOR_BLACK)
        curses.init_pair(4, curses.COLOR_MAGENTA, curses.COLOR_BLACK)
        curses.init_pair(5, curses.COLOR_RED, curses.COLOR_BLACK)
        curses.init_pair(6, curses.COLOR_YELLOW, curses.COLOR_BLACK)

    def run(self):
        self.stdscr.timeout(50)
        screen = self.get_screen_state()
        columns = [self._create_column(screen) for _ in range(screen.width)]
        frame_count = 0

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()

            for x, col in enumerate(columns):
                self._update_column(col, screen, x, frame_count)
                self._draw_column(col, x, screen, frame_count)

            self.stdscr.refresh()
            frame_count += 1

    def _create_column(self, screen: ScreenState) -> dict:
        char_set = self._get_char_set()
        return {
            "y": random.randint(-screen.height, 0),
            "speed": random.uniform(0.3, 1.5),
            "chars": [random.choice(char_set) for _ in range(screen.height)],
            "color": random.choice([1, 3, 4]),
            "length": random.randint(8, 25),
            "flash": 0,
            "frozen": False,
            "freeze_timer": 0,
        }

    def _get_char_set(self):
        if self.variant == "japanese":
            return self.JAPANESE_CHARS
        elif self.variant == "binary":
            return self.BINARY_CHARS
        elif self.variant == "mixed":
            if random.random() < 0.5:
                return self.CHARS
            else:
                return self.JAPANESE_CHARS
        return self.CHARS

    def _update_column(self, col: dict, screen: ScreenState, x: int, frame: int):
        # Handle frozen columns
        if col["frozen"]:
            col["freeze_timer"] -= 1
            if col["freeze_timer"] <= 0:
                col["frozen"] = False
            return

        # Apply variant-specific speed modifications
        speed = col["speed"]

        col["y"] += speed

        # Reset column when it goes off screen
        if col["y"] - col["length"] > screen.height:
            col["y"] = random.randint(-screen.height // 2, 0)
            col["speed"] = random.uniform(0.3, 1.5)
            col["length"] = random.randint(8, 25)
            char_set = self._get_char_set()
            col["chars"] = [random.choice(char_set) for _ in range(screen.height)]
            col["color"] = random.choice([1, 3, 4])

        # Random character changes
        change_rate = 0.1 if self.variant != "glitch" else 0.3
        if random.random() < change_rate:
            idx = random.randint(0, len(col["chars"]) - 1)
            char_set = self._get_char_set()
            col["chars"][idx] = random.choice(char_set)

        # Decay flash
        if col["flash"] > 0:
            col["flash"] -= 1

    def _draw_column(self, col: dict, x: int, screen: ScreenState, frame: int):
        for i in range(col["length"]):
            y = int(col["y"] - i)
            if screen.in_bounds(y, x):
                char_idx = y % len(col["chars"])

                # Determine color and brightness
                if col["flash"] > 0:
                    color = curses.color_pair(2) | curses.A_BOLD
                elif i == 0:
                    color = curses.color_pair(2) | curses.A_BOLD
                elif i < col["length"] // 3:
                    color = curses.color_pair(col["color"]) | curses.A_BOLD
                else:
                    color = curses.color_pair(col["color"])

                # Variant-specific modifications
                if self.variant == "rainbow":
                    rainbow_color = self._get_rainbow_color(frame + y + x)
                    color = curses.color_pair(rainbow_color)
                elif self.variant == "fade":
                    if i > col["length"] * 0.7:
                        color = curses.color_pair(col["color"]) | curses.A_DIM

                self.safe_addstr(y, x, col["chars"][char_idx], color)

    def _trigger_glitch(self, columns: list, screen: ScreenState):
        """Create a glitch effect"""
        num_affected = random.randint(3, 10)
        for _ in range(num_affected):
            col_idx = random.randint(0, len(columns) - 1)
            col = columns[col_idx]
            col["flash"] = random.randint(3, 8)
            col["color"] = random.choice([2, 5, 6])

            # Randomly freeze some columns
            if random.random() < 0.3:
                col["frozen"] = True
                col["freeze_timer"] = random.randint(10, 30)

    def _draw_spotlight(self, screen: ScreenState, frame: int):
        """Draw a moving spotlight effect"""
        center_x = int(screen.width / 2 + screen.width / 3 * math.sin(frame * 0.02))
        center_y = int(screen.height / 2 + screen.height / 3 * math.cos(frame * 0.03))

        # Dim areas outside spotlight
        for y in range(screen.height):
            for x in range(0, screen.width, 2):
                if screen.in_bounds(y, x):
                    dist = math.sqrt((x - center_x)**2 + (y - center_y)**2)
                    if dist > 15:
                        self.safe_addstr(y, x, " ", curses.color_pair(0))

    def _draw_ripple(self, screen: ScreenState, frame: int):
        """Draw ripple interference patterns"""
        center_x = screen.width // 2
        center_y = screen.height // 2

        for y in range(0, screen.height, 2):
            for x in range(0, screen.width, 2):
                if screen.in_bounds(y, x):
                    dist = math.sqrt((x - center_x)**2 + (y - center_y)**2)
                    if abs(math.sin(dist * 0.5 - frame * 0.1)) > 0.9:
                        self.safe_addstr(y, x, "·", curses.color_pair(3))

    def _get_rainbow_color(self, value: int) -> int:
        """Get cycling rainbow color"""
        colors = [1, 3, 4, 6, 5]
        return colors[(value // 5) % len(colors)]


class SpiralGalaxy(BaseEffect):
    """Rotating spiral galaxy pattern"""

    CHARS = " .·*✦★✧"

    def run(self):
        angle = 0

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()
            center_y, center_x = screen.center

            for y in range(screen.height):
                for x in range(screen.width):
                    dx = x - center_x
                    dy = (y - center_y) * 2

                    distance = math.sqrt(dx * dx + dy * dy)
                    theta = math.atan2(dy, dx)

                    spiral = math.sin(distance / 5.0 - theta * 2 + angle)
                    pulse = math.sin(distance / 10.0 + angle * 2)
                    value = (spiral + pulse) / 2

                    if value > 0.3:
                        char_idx = min(
                            int((value + 1) * (len(self.CHARS) - 1) / 2),
                            len(self.CHARS) - 1,
                        )
                        color_idx = min(int((value + 1) * 3.5) + 1, 7)
                        attr = curses.color_pair(color_idx)
                        if value > 0.8:
                            attr |= curses.A_BOLD

                        self.safe_addstr(y, x, self.CHARS[char_idx], attr)

            self.stdscr.refresh()
            angle += 0.05

# TODO: Need to improve fire effect to make it look realistic, kinda look like a chump
class FireEffect(BaseEffect):
    """Realistic fire simulation with improved physics"""

    CHARS = " ^.·:;+=xX$&#@powrjmeesjdds▁▂▃▄▅▆▇█"

    def setup_colors(self):
        super().setup_colors()
        # More realistic fire color palette
        curses.init_pair(1, curses.COLOR_RED, curses.COLOR_BLACK)  # Dark red/embers
        curses.init_pair(2, curses.COLOR_RED, curses.COLOR_BLACK)  # Red
        curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Orange-yellow
        curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Yellow
        curses.init_pair(5, curses.COLOR_WHITE, curses.COLOR_BLACK)  # White hot
        curses.init_pair(
            6, curses.COLOR_CYAN, curses.COLOR_BLACK
        )  # Blue core (hottest)
        curses.init_pair(
            7, curses.COLOR_MAGENTA, curses.COLOR_BLACK
        )  # Purple highlights

    def run(self):
        self.stdscr.timeout(30)  # Faster update for smoother animation
        screen = self.get_screen_state()

        # Fire buffer with heat values
        fire = [[0.0] * screen.width for _ in range(screen.height)]

        # Velocity field for turbulence
        velocity = [[0.0] * screen.width for _ in range(screen.height)]

        time_step = 0

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()

            fire = self._resize_fire_buffer(fire, screen)
            velocity = self._resize_fire_buffer(velocity, screen)

            # Add dynamic heat source at bottom with flickering
            self._add_heat_source(fire, screen, time_step)

            # Add turbulence and wind effects
            self._apply_turbulence(fire, velocity, screen, time_step)

            # Propagate fire upward with realistic physics
            self._propagate_fire(fire, velocity, screen)

            # Draw the fire
            self._draw_fire(fire, screen)

            self.stdscr.refresh()
            time_step += 1

    def _resize_fire_buffer(self, buffer: list, screen: ScreenState) -> list:
        """Resize buffer to match screen dimensions"""
        while len(buffer) < screen.height:
            buffer.append([0.0] * screen.width)
        while len(buffer) > screen.height:
            buffer.pop()
        for row in buffer:
            while len(row) < screen.width:
                row.append(0.0)
            while len(row) > screen.width:
                row.pop()
        return buffer

    def _add_heat_source(self, fire: list, screen: ScreenState, time_step: int):
        """Add dynamic, flickering heat source at bottom"""
        center = screen.width // 2
        width_variation = int(screen.width * 0.4)

        for x in range(screen.width):
            # Distance from center affects intensity
            distance_from_center = abs(x - center) / (screen.width / 2)

            # Flickering effect using sine waves
            flicker = (
                0.8
                + 0.15 * math.sin(time_step * 0.1 + x * 0.3)
                + 0.1 * math.sin(time_step * 0.23 + x * 0.15)
                + 0.05 * random.random()
            )

            # Create a bell curve distribution for fire width
            intensity = math.exp(-3 * (distance_from_center**2)) * flicker

            # Add random hot spots
            if random.random() < 0.05:
                intensity = min(1.0, intensity + random.uniform(0.2, 0.4))

            fire[screen.height - 1][x] = max(0.6, min(1.0, intensity))

            # Add some heat to second-to-last row for stronger base
            if screen.height > 1:
                fire[screen.height - 2][x] = max(
                    fire[screen.height - 2][x], intensity * 0.7
                )

    def _apply_turbulence(
        self, fire: list, velocity: list, screen: ScreenState, time_step: int
    ):
        """Add turbulence and swirling effects"""
        for y in range(screen.height - 3, 0, -1):
            for x in range(1, screen.width - 1):
                # Create swirling motion using Perlin-like noise
                swirl = (
                    0.3
                    * math.sin(x * 0.1 + time_step * 0.05)
                    * math.cos(y * 0.15 + time_step * 0.03)
                )

                velocity[y][x] = swirl

                # Add random gusts
                if random.random() < 0.02:
                    velocity[y][x] += random.uniform(-0.3, 0.3)

    def _propagate_fire(self, fire: list, velocity: list, screen: ScreenState):
        """Propagate fire upward with realistic cooling and dispersion"""
        new_fire = [[0.0] * screen.width for _ in range(screen.height)]

        for y in range(screen.height - 2, -1, -1):
            for x in range(screen.width):
                # Gather heat from below with weighted average
                heat = 0.0
                weight_sum = 0.0

                # Sample from 5 cells below (wider dispersion)
                for dx in range(-2, 3):
                    nx = x + dx
                    if 0 <= nx < screen.width and y + 1 < screen.height:
                        # Weight based on distance
                        weight = 1.0 / (1.0 + abs(dx) * 0.5)

                        # Apply velocity-based displacement
                        velocity_offset = int(velocity[y][x] * 2)
                        final_x = max(0, min(screen.width - 1, nx + velocity_offset))

                        heat += fire[y + 1][final_x] * weight
                        weight_sum += weight

                if weight_sum > 0:
                    heat /= weight_sum

                # Heat rises but cools down (variable cooling rate)
                cooling_rate = random.uniform(0.03, 0.12)

                # More aggressive cooling higher up
                height_factor = 1.0 - (y / screen.height)
                cooling_rate *= 1.0 + height_factor * 0.5

                # Some heat dissipates more at edges
                edge_distance = min(x, screen.width - 1 - x) / (screen.width / 2)
                if edge_distance < 0.3:
                    cooling_rate *= 1.5

                new_fire[y][x] = max(0, heat - cooling_rate)

                # Add occasional sparks at high heat areas
                if new_fire[y][x] > 0.7 and random.random() < 0.01:
                    spark_height = random.randint(1, 3)
                    for sy in range(max(0, y - spark_height), y):
                        if 0 <= sy < screen.height:
                            new_fire[sy][x] = max(
                                new_fire[sy][x], random.uniform(0.6, 0.9)
                            )

        # Copy new fire state back
        for y in range(screen.height):
            for x in range(screen.width):
                fire[y][x] = new_fire[y][x]

    def _draw_fire(self, fire: list, screen: ScreenState):
        """Draw fire with realistic color temperature mapping"""
        for y in range(screen.height):
            for x in range(screen.width):
                val = fire[y][x]

                if val > 0.02:  # Lower threshold for embers
                    # Map heat to character density
                    char_idx = min(
                        int(
                            val * val * (len(self.CHARS) - 1)
                        ),  # Squared for better contrast
                        len(self.CHARS) - 1,
                    )

                    # Realistic color temperature mapping
                    if val > 0.9:
                        # Blue-white core (hottest)
                        color = curses.color_pair(6) | curses.A_BOLD
                    elif val > 0.75:
                        # White hot
                        color = curses.color_pair(5) | curses.A_BOLD
                    elif val > 0.6:
                        # Bright yellow
                        color = curses.color_pair(4) | curses.A_BOLD
                    elif val > 0.45:
                        # Yellow-orange
                        color = curses.color_pair(3) | curses.A_BOLD
                    elif val > 0.3:
                        # Orange
                        color = curses.color_pair(3)
                    elif val > 0.15:
                        # Red-orange
                        color = curses.color_pair(2)
                    else:
                        # Dark red embers
                        color = curses.color_pair(1)

                    # Add occasional purple/magenta highlights for realism
                    if val > 0.8 and random.random() < 0.1:
                        color = curses.color_pair(7) | curses.A_BOLD

                    self.safe_addstr(y, x, self.CHARS[char_idx], color)


class JuliaSet(BaseEffect):
    """Animated Julia set fractal"""

    CHARS = " .·:░▒▓█"

    def run(self):
        angle = 0

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()

            # Animate the Julia set parameter
            c_real = 0.7885 * math.cos(angle)
            c_imag = 0.7885 * math.sin(angle)

            for y in range(screen.height):
                for x in range(screen.width):
                    # Map pixel to complex plane
                    z_real = (x - screen.width / 2) / (screen.width / 4)
                    z_imag = (y - screen.height / 2) / (screen.height / 4)

                    iterations = self._julia_iterations(z_real, z_imag, c_real, c_imag)

                    if iterations == 50:
                        char = self.CHARS[-1]
                        color = curses.color_pair(7) | curses.A_BOLD
                    else:
                        char_idx = min(iterations // 6, len(self.CHARS) - 1)
                        color_idx = min((iterations % 7) + 1, 7)
                        char = self.CHARS[char_idx]
                        color = curses.color_pair(color_idx)

                    self.safe_addstr(y, x, char, color)

            self.stdscr.refresh()
            angle += 0.05

    def _julia_iterations(
        self,
        z_real: float,
        z_imag: float,
        c_real: float,
        c_imag: float,
        max_iter: int = 50,
    ) -> int:
        for i in range(max_iter):
            if z_real * z_real + z_imag * z_imag > 4:
                return i
            z_real, z_imag = (
                z_real * z_real - z_imag * z_imag + c_real,
                2 * z_real * z_imag + c_imag,
            )
        return max_iter


class LorenzAttractor(BaseEffect):
    """Chaotic Lorenz attractor visualization"""

    CHARS = " .·*○●"

    def run(self):
        # Lorenz system parameters
        sigma, rho, beta = 10.0, 28.0, 8.0 / 3.0
        dt = 0.01

        # Multiple particles
        particles = [
            {
                "x": random.uniform(-10, 10),
                "y": random.uniform(-10, 10),
                "z": random.uniform(0, 40),
                "history": [],
            }
            for _ in range(5)
        ]

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()

            for particle in particles:
                # Update particle position using Lorenz equations
                dx = sigma * (particle["y"] - particle["x"]) * dt
                dy = (particle["x"] * (rho - particle["z"]) - particle["y"]) * dt
                dz = (particle["x"] * particle["y"] - beta * particle["z"]) * dt

                particle["x"] += dx
                particle["y"] += dy
                particle["z"] += dz

                particle["history"].append(
                    (particle["x"], particle["y"], particle["z"])
                )
                if len(particle["history"]) > 200:
                    particle["history"].pop(0)

            # Draw all particle trails
            for particle in particles:
                for i, (x, y, z) in enumerate(particle["history"]):
                    # Project 3D to 2D
                    screen_x = int(screen.width / 2 + x * 2)
                    screen_y = int(screen.height / 2 - z / 2)

                    if screen.in_bounds(screen_y, screen_x):
                        age = i / len(particle["history"])
                        char_idx = min(int(age * len(self.CHARS)), len(self.CHARS) - 1)
                        color_idx = min(int(age * 6) + 1, 7)

                        self.safe_addstr(
                            screen_y,
                            screen_x,
                            self.CHARS[char_idx],
                            curses.color_pair(color_idx),
                        )

            self.stdscr.refresh()


class VoronoiDiagram(BaseEffect):
    """Animated Voronoi diagram"""

    CHARS = " ░▒▓█"

    def run(self):
        screen = self.get_screen_state()

        # Create moving points
        points = [
            {
                "x": random.randint(0, screen.width - 1),
                "y": random.randint(0, screen.height - 1),
                "vx": random.uniform(-0.5, 0.5),
                "vy": random.uniform(-0.5, 0.5),
                "color": i % 7 + 1,
            }
            for i in range(8)
        ]

        while not self.should_exit():
            self.stdscr.erase()
            screen = self.get_screen_state()

            # Update point positions
            for point in points:
                point["x"] += point["vx"]
                point["y"] += point["vy"]

                if point["x"] < 0 or point["x"] >= screen.width:
                    point["vx"] *= -1
                if point["y"] < 0 or point["y"] >= screen.height:
                    point["vy"] *= -1

                point["x"] = max(0, min(screen.width - 1, point["x"]))
                point["y"] = max(0, min(screen.height - 1, point["y"]))

            # Draw Voronoi cells
            for y in range(screen.height):
                for x in range(screen.width):
                    # Find closest point
                    min_dist = float("inf")
                    closest_point = None

                    for point in points:
                        dx = x - point["x"]
                        dy = (y - point["y"]) * 2  # Aspect ratio correction
                        dist = math.sqrt(dx * dx + dy * dy)

                        if dist < min_dist:
                            min_dist = dist
                            closest_point = point

                    if closest_point:
                        char_idx = min(int(min_dist / 10), len(self.CHARS) - 1)
                        self.safe_addstr(
                            y,
                            x,
                            self.CHARS[char_idx],
                            curses.color_pair(closest_point["color"]),
                        )

            self.stdscr.refresh()


# Registry of all available effects
EFFECTS: Dict[str, type] = {
    "matrix": MatrixRain,
    "plasma": PlasmaWave,
    "spiral": SpiralGalaxy,
    "fire": FireEffect,
    "julia": JuliaSet,
    "lorenz": LorenzAttractor,
    # 'fourier': FourierWaves,
    # 'life': ConwayLife,
    "voronoi": VoronoiDiagram,
    # 'perlin': PerlinNoise,
}

#  TODO:
# Add mandelbrot, perlin
def main():
    parser = argparse.ArgumentParser(
        description="Terminal Screensaver",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available modes:
  matrix      - Matrix-style digital rain
  plasma      - Plasma wave interference patterns
  spiral      - Rotating spiral galaxy
  fire        - Realistic fire simulation (currenlty in work)
  julia       - Animated Julia set fractal
  voronoi     - Bunch of colored blobs
  lorenz      - Lorenz attractor (chaos theory)

Matrix variants (use with --matrix-variant):
  classic     - Classic green Matrix rain (default)
  japanese    - Japanese katakana characters
  binary      - Binary (0 and 1) rain
  mixed       - Mix of ASCII and Japanese
        """,
    )
    parser.add_argument(
        "--mode",
        "-m",
        choices=list(EFFECTS.keys()),
        default="spiral",
        help="Screensaver mode (default: Spiral)",
    )
    parser.add_argument(
        "--matrix-variant",
        "-v",
        choices=["classic", "japanese", "binary", "mixed"],
        default="classic",
        help="Matrix effect variant (default: classic)",
    )
    parser.add_argument(
        "--list", "-l", action="store_true", help="List all available modes and exit"
    )

    args = parser.parse_args()

    if args.list:
        print("Available screensaver modes:")
        for mode, effect_class in EFFECTS.items():
            print(f"  {mode:12} - {effect_class.__doc__}")
        return

    try:
        print(f"Starting '{args.mode}' screensaver...")
        if args.mode == "matrix":
            print(f"Variant: {args.matrix_variant}")
        print("Press any key to exit.")
        time.sleep(1)

        def run_effect(stdscr):
            if args.mode == "matrix":
                effect = EFFECTS[args.mode](stdscr, variant=args.matrix_variant)
            else:
                effect = EFFECTS[args.mode](stdscr)
            effect.run()

        curses.wrapper(run_effect)
    except KeyboardInterrupt:
        pass
    finally:
        print("\nScreensaver stopped.")


if __name__ == "__main__":
    main()
